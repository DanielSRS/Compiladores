/**
Estrutura do prgrama:
Delacação de constantes: Opcional;
Declaração de estruturas e extends: Opcional
Declaração de variáveis globais: Opcional
Declaração de funções e procedimentos: Nescessário


Algumas diferenças acabaram surgindo entra essa gramtica e a anterior,
sendo as mais relevantes, a mudança na ordem da estrutura do programa,
que começa com as contantes (antes começava com as estruturas)

o extends de um tipo composto também mudou, agora também começa com a PRE struct,
antes ja começava com o identificador.
*/

/**
Declaração de contantes
*/
const { 
  boolean f;

  /**
    É possivel atribuir expressões aritméticas a variáveis
  */
  int expressao = (a_exp * b_exp / t_exp + 456);
}

/**
Declaração de estruturas
*/
struct foo {
  // Declaração de listas de membros da estrutura com ou sem atribuição
  string bfoo, cfoo, dfoo, efoo = 88, hfoo = "string", xfoo;
  int yfoo = a_matrix_foo_struct[d]; // atribuição com valor de elemento de matriz
  string bfoo2;
}
struct bar extends foo {
  int hoo = k(); // atribuição com valor de retorno de função
  foo fb = (H[87] * i + (a + b)); // atribuição com valor aritmético
}
struct iel {
  int a = "sdf";
  string hiel, riel, eiel, tiel, yiel;
}
struct s extends r {
  boolean f_s = false;
  int y_s[kjhk][][454];       // Declaração de matriz multidimensional
  string b_s = true;
  string h_s, r_s = lkj(), e_s[], t_s[][], y_s;
}

var { string b_var = bcomposto.d; }

function int Start(int a, string b, fof slkjf) {

}

function real Foo() {

}
function boolean Bar() {}

procedure pro () {
  // While aceita expressoes relacionais ou logicas
  while (da_.a > b) {
    while (A_while || (B && lkj()) ) {

    } 
    
    if ( if_a || C && (fun() || kj[o])) then {

    } 
  }

  // If aceita expressoes relacionais ou logicas
  if (cond_a || C) then {

  } else { 
    while (f[2] >= po[er]) {

    } 
  }

  matri[sdf][54][54] = "";      //  atribuição de valor a elemento da matriz
  print(matri[sdf][54][54]);    // print de elemento de matriz
  print(oiu);                   // print de variável
  print("laksdjfkl lsakdfj laskjdf"); // print de string
  print(tipo.composo);              // print de tipo composto

  // stribuição de variáveis
  v = 34;
  lkj[sdf] = lkj();

  prin(); // chamada de funções

  read(matri[sdf][54][54]);
  read(oiu);
  read(tipo.composo);

  var { 
    string b_local_pro_var = b.d;
    string nome_local_pro_var = "Dionisio santini "; 
  }

}

function string count(strut lk) {}

function foo char() {
  var { 
    string b_local_foo_var = b.d;
    string nome_local_foo_var = "Dionisio santini "; 
  }
}
